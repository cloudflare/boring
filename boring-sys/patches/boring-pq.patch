From cb5689e091f515fc8a42ceaff08d702333e505ed Mon Sep 17 00:00:00 2001
From: Anthony Ramine <aramine@cloudflare.com>
Date: Wed, 3 Dec 2025 11:10:16 +0100
Subject: [PATCH] Add additional post-quantum key agreements

This patch adds:

1. Enable X25519MLKEM768 by default.

2. Supports for P256Kyber768Draft00 under 0xfe32, which we temporarily
   need for compliance reasons.  (Note that this is not the codepoint
   allocated for that exchange in the IANA table.)
   Enables by default and in FIPS mode.

3. Add SSL(_CTX)_use_second_keyshare.  By default BoringSSL will send a
   non post-quantum and a post-quantum keyshare if available.  These
   functions allow one to change the behaviour to only send a single
   keyshare.
---
 crypto/obj/obj_dat.h                |   6 +-
 crypto/obj/obj_mac.num              |   1 +
 crypto/obj/objects.txt              |   1 +
 include/openssl/nid.h               |   3 +
 include/openssl/ssl.h               |  15 ++++
 ssl/extensions.cc                   |  26 ++++---
 ssl/internal.h                      |  12 ++-
 ssl/ssl_key_share.cc                | 111 +++++++++++++++++++++++++++-
 ssl/ssl_lib.cc                      |  16 +++-
 ssl/ssl_test.cc                     |  19 ++++-
 ssl/test/runner/basic_tests.go      |   2 +
 ssl/test/runner/cbc_tests.go        |   3 +
 ssl/test/runner/common.go           |   2 +-
 ssl/test/runner/curve_tests.go      |  28 +++----
 ssl/test/runner/ech_tests.go        |  24 +++++-
 ssl/test/runner/extension_tests.go  |   3 +-
 ssl/test/runner/key_update_tests.go |   6 +-
 tool/client.cc                      |   9 +++
 18 files changed, 245 insertions(+), 42 deletions(-)

diff --git a/crypto/obj/obj_dat.h b/crypto/obj/obj_dat.h
index d8b86dcd2..6dd49ec36 100644
--- a/crypto/obj/obj_dat.h
+++ b/crypto/obj/obj_dat.h
@@ -15,7 +15,7 @@
 // This file is generated by crypto/obj/objects.go.
 
 
-#define NUM_NID 971
+#define NUM_NID 972
 
 static const uint8_t kObjectData[] = {
     /* NID_rsadsi */
@@ -8799,6 +8799,8 @@ static const ASN1_OBJECT kObjects[NUM_NID] = {
     {"id-ml-dsa-87", "ML-DSA-87", NID_ML_DSA_87, 9, &kObjectData[6223], 0},
     {"id-alg-ml-kem-768", "ML-KEM-768", NID_ML_KEM_768, 9, &kObjectData[6232],
      0},
+    {"P256Kyber768Draft00", "P256Kyber768Draft00", NID_P256Kyber768Draft00, 0,
+     NULL, 0},
 };
 
 static const uint16_t kNIDsInShortNameOrder[] = {
@@ -8931,6 +8933,7 @@ static const uint16_t kNIDsInShortNameOrder[] = {
     18 /* OU */,
     749 /* Oakley-EC2N-3 */,
     750 /* Oakley-EC2N-4 */,
+    971 /* P256Kyber768Draft00 */,
     9 /* PBE-MD2-DES */,
     168 /* PBE-MD2-RC2-64 */,
     10 /* PBE-MD5-DES */,
@@ -9854,6 +9857,7 @@ static const uint16_t kNIDsInLongNameOrder[] = {
     366 /* OCSP Nonce */,
     371 /* OCSP Service Locator */,
     180 /* OCSP Signing */,
+    971 /* P256Kyber768Draft00 */,
     161 /* PBES2 */,
     69 /* PBKDF2 */,
     162 /* PBMAC1 */,
diff --git a/crypto/obj/obj_mac.num b/crypto/obj/obj_mac.num
index ae863e29d..7231b9a58 100644
--- a/crypto/obj/obj_mac.num
+++ b/crypto/obj/obj_mac.num
@@ -958,3 +958,4 @@ ML_DSA_44		967
 ML_DSA_65		968
 ML_DSA_87		969
 ML_KEM_768		970
+P256Kyber768Draft00		971
diff --git a/crypto/obj/objects.txt b/crypto/obj/objects.txt
index 1e0cb76db..e8b249dfd 100644
--- a/crypto/obj/objects.txt
+++ b/crypto/obj/objects.txt
@@ -1340,6 +1340,7 @@ secg-scheme 14 3 : dhSinglePass-cofactorDH-sha512kdf-scheme
 
 # NIDs for post quantum hybrid KEMs in TLS (no corresponding OIDs).
  : X25519Kyber768Draft00
+ : P256Kyber768Draft00
  : X25519MLKEM768
 
 # See RFC 8410.
diff --git a/include/openssl/nid.h b/include/openssl/nid.h
index 83a1cf592..7265f15f6 100644
--- a/include/openssl/nid.h
+++ b/include/openssl/nid.h
@@ -5508,6 +5508,9 @@ extern "C" {
 #define OBJ_ML_KEM_768 2L, 16L, 840L, 1L, 101L, 3L, 4L, 4L, 2L
 #define OBJ_ENC_ML_KEM_768 0x60, 0x86, 0x48, 0x01, 0x65, 0x03, 0x04, 0x04, 0x02
 
+#define SN_P256Kyber768Draft00 "P256Kyber768Draft00"
+#define NID_P256Kyber768Draft00 971
+
 
 #if defined(__cplusplus)
 } /* extern C */
diff --git a/include/openssl/ssl.h b/include/openssl/ssl.h
index ff68ba69e..0730e769a 100644
--- a/include/openssl/ssl.h
+++ b/include/openssl/ssl.h
@@ -2550,6 +2550,7 @@ OPENSSL_EXPORT size_t SSL_CTX_get_num_tickets(const SSL_CTX *ctx);
 #define SSL_GROUP_X25519_MLKEM768 0x11ec
 #define SSL_GROUP_X25519_KYBER768_DRAFT00 0x6399
 #define SSL_GROUP_MLKEM1024 0x0202
+#define SSL_GROUP_P256_KYBER768_DRAFT00 0xfe32
 
 // SSL_CTX_set1_group_ids sets the preferred groups for |ctx| to |group_ids|.
 // Each element of |group_ids| should be a unique one of the |SSL_GROUP_*|
@@ -5964,6 +5965,20 @@ OPENSSL_EXPORT int SSL_CTX_set1_curves_list(SSL_CTX *ctx, const char *curves);
 // SSL_set1_curves_list calls |SSL_set1_groups_list|.
 OPENSSL_EXPORT int SSL_set1_curves_list(SSL *ssl, const char *curves);
 
+// By default, a client will send both a non post-quantum and a post-quantum
+// keyshare if available.
+//
+// SSL_use_second_keyshare controls this behaviour. If |enabled| is 0, then
+// a client using |ssl| will only send one keyshare.
+OPENSSL_EXPORT void SSL_use_second_keyshare(SSL *ssl, int enabled);
+
+// By default, a client will send both a non post-quantum and a post-quantum
+// keyshare if available.
+//
+// SSL_CTX_use_second_keyshare controls this behaviour. If |enabled| is 0, then
+// a client using |ctx| will only send one keyshare.
+OPENSSL_EXPORT void SSL_CTX_use_second_keyshare(SSL_CTX *ctx, int enabled);
+
 // TLSEXT_nid_unknown is a constant used in OpenSSL for
 // |SSL_get_negotiated_group| to return an unrecognized group. BoringSSL never
 // returns this value, but we define this constant for compatibility.
diff --git a/ssl/extensions.cc b/ssl/extensions.cc
index c5f90688c..e0514fed3 100644
--- a/ssl/extensions.cc
+++ b/ssl/extensions.cc
@@ -101,6 +101,7 @@ static bool tls1_check_duplicate_extensions(const CBS *cbs) {
 static bool is_post_quantum_group(uint16_t id) {
   switch (id) {
     case SSL_GROUP_X25519_KYBER768_DRAFT00:
+    case SSL_GROUP_P256_KYBER768_DRAFT00:
     case SSL_GROUP_X25519_MLKEM768:
     case SSL_GROUP_MLKEM1024:
       return true;
@@ -2241,18 +2242,21 @@ bool ssl_setup_key_shares(SSL_HANDSHAKE *hs, uint16_t override_group_id) {
     if (!default_key_shares.TryPushBack(supported_group_list[0])) {
       return false;
     }
-    // We'll try to include one post-quantum and one classical initial key
-    // share.
-    for (size_t i = 1; i < supported_group_list.size(); i++) {
-      if (is_post_quantum_group(default_key_shares[0]) ==
-          is_post_quantum_group(supported_group_list[i])) {
-        continue;
-      }
-      if (!default_key_shares.TryPushBack(supported_group_list[i])) {
-        return false;
+
+    if (!ssl->config->disable_second_keyshare) {
+      // We'll try to include one post-quantum and one classical initial key
+      // share.
+      for (size_t i = 1; i < supported_group_list.size(); i++) {
+        if (is_post_quantum_group(default_key_shares[0]) ==
+            is_post_quantum_group(supported_group_list[i])) {
+          continue;
+        }
+        if (!default_key_shares.TryPushBack(supported_group_list[i])) {
+          return false;
+        }
+        assert(default_key_shares[1] != default_key_shares[0]);
+        break;
       }
-      assert(default_key_shares[1] != default_key_shares[0]);
-      break;
     }
     selected_key_shares.emplace(default_key_shares);
   }
diff --git a/ssl/internal.h b/ssl/internal.h
index a69505b47..1f5ce51e6 100644
--- a/ssl/internal.h
+++ b/ssl/internal.h
@@ -955,7 +955,7 @@ struct NamedGroup {
 Span<const NamedGroup> NamedGroups();
 
 // kNumNamedGroups is the number of supported groups.
-constexpr size_t kNumNamedGroups = 7u;
+constexpr size_t kNumNamedGroups = 8u;
 
 // DefaultSupportedGroupIds returns the list of IDs for the default groups that
 // are supported when the caller hasn't explicitly configured supported groups.
@@ -3388,6 +3388,11 @@ struct SSL_CONFIG {
   // permute_extensions is whether to permute extensions when sending messages.
   bool permute_extensions : 1;
 
+  // As a client by default we will send a non post-quantum share and
+  // a post-quantum share if available. If disable_second_keyshare is set,
+  // we will only send the most preferred keyshare.
+  bool disable_second_keyshare : 1;
+
   // aes_hw_override if set indicates we should override checking for aes
   // hardware support, and use the value in aes_hw_override_value instead.
   bool aes_hw_override : 1;
@@ -4015,6 +4020,11 @@ struct ssl_ctx_st : public bssl::RefCounted<ssl_ctx_st> {
   // permute_extensions is whether to permute extensions when sending messages.
   bool permute_extensions : 1;
 
+  // As a client by default we will send a non post-quantum share and
+  // a post-quantum share if available. If disable_second_keyshare is set,
+  // we will only send the most preferred keyshare.
+  bool disable_second_keyshare : 1;
+
   // allow_unknown_alpn_protos is whether the client allows unsolicited ALPN
   // protocols from the peer.
   bool allow_unknown_alpn_protos : 1;
diff --git a/ssl/ssl_key_share.cc b/ssl/ssl_key_share.cc
index d155b5527..4fb08906b 100644
--- a/ssl/ssl_key_share.cc
+++ b/ssl/ssl_key_share.cc
@@ -193,6 +193,109 @@ class X25519KeyShare : public SSLKeyShare {
   uint8_t private_key_[32];
 };
 
+class P256Kyber768Draft00KeyShare : public SSLKeyShare {
+ public:
+  P256Kyber768Draft00KeyShare()
+    : ecks_(EC_group_p256(), SSL_GROUP_SECP256R1) {}
+
+  uint16_t GroupID() const override {
+    return SSL_GROUP_P256_KYBER768_DRAFT00;
+  }
+
+  bool Generate(CBB *out) override {
+    uint8_t kyber_public_key[KYBER_PUBLIC_KEY_BYTES];
+    KYBER_generate_key(kyber_public_key, &kyber_private_key_);
+
+    if(!ecks_.Generate(out) ||
+       !CBB_add_bytes(out, kyber_public_key, sizeof(kyber_public_key))) {
+      return false;
+    }
+
+    return true;
+  }
+
+  bool Encap(CBB *out_ciphertext, Array<uint8_t> *out_secret,
+             uint8_t *out_alert, Span<const uint8_t> peer_key) override {
+    Array<uint8_t> ec_secret;
+
+    *out_alert = SSL_AD_INTERNAL_ERROR;
+
+    if(peer_key.size() != p256_share_size + KYBER_PUBLIC_KEY_BYTES) {
+      *out_alert = SSL_AD_ILLEGAL_PARAMETER;
+      OPENSSL_PUT_ERROR(SSL, SSL_R_BAD_ECPOINT);
+      return false;
+    }
+
+    if (!ecks_.Encap(out_ciphertext, &ec_secret, out_alert,
+                    peer_key.subspan(0, p256_share_size))) {
+      return false;
+    }
+
+    KYBER_public_key peer_kyber_pub;
+    CBS peer_kyber_cbs;
+    CBS_init(&peer_kyber_cbs, peer_key.data() + p256_share_size,
+             KYBER_PUBLIC_KEY_BYTES);
+
+    if (!KYBER_parse_public_key(&peer_kyber_pub, &peer_kyber_cbs)) {
+      *out_alert = SSL_AD_ILLEGAL_PARAMETER;
+      OPENSSL_PUT_ERROR(SSL, SSL_R_BAD_ECPOINT);
+      return false;
+    }
+
+    uint8_t kyber_ciphertext[KYBER_CIPHERTEXT_BYTES];
+    Array<uint8_t> secret;
+    if (!secret.InitForOverwrite(p256_secret_size + KYBER_SHARED_SECRET_BYTES)) {
+      return false;
+    }
+    OPENSSL_memcpy(secret.data(), ec_secret.data(), ec_secret.size());
+    KYBER_encap(kyber_ciphertext, secret.data() + p256_secret_size,
+                &peer_kyber_pub);
+
+    if(!CBB_add_bytes(out_ciphertext, kyber_ciphertext,
+                       sizeof(kyber_ciphertext))) {
+      return false;
+    }
+
+    *out_secret = std::move(secret);
+    return true;
+  }
+
+  bool Decap(Array<uint8_t> *out_secret, uint8_t *out_alert,
+             Span<const uint8_t> ciphertext) override {
+    *out_alert = SSL_AD_INTERNAL_ERROR;
+
+    Array<uint8_t> ec_secret;
+
+    if (ciphertext.size() != p256_share_size + KYBER_CIPHERTEXT_BYTES) {
+      *out_alert = SSL_AD_ILLEGAL_PARAMETER;
+      OPENSSL_PUT_ERROR(SSL, SSL_R_BAD_ECPOINT);
+      return false;
+    }
+
+    if (!ecks_.Decap(&ec_secret, out_alert,
+                     ciphertext.subspan(0, p256_share_size))) {
+      return false;
+    }
+
+    Array<uint8_t> secret;
+    if (!secret.InitForOverwrite(p256_secret_size + KYBER_SHARED_SECRET_BYTES)) {
+      return false;
+    }
+    OPENSSL_memcpy(secret.data(), ec_secret.data(), ec_secret.size());
+    KYBER_decap(secret.data() + p256_secret_size,
+                ciphertext.data() + p256_share_size, &kyber_private_key_);
+    *out_secret = std::move(secret);
+    return true;
+  }
+
+ private:
+  ECKeyShare ecks_;
+  KYBER_private_key kyber_private_key_;
+
+  static constexpr size_t p256_share_size = 65;
+  static constexpr size_t p256_secret_size = 32;
+};
+
 // draft-tls-westerbaan-xyber768d00-03
 class X25519Kyber768KeyShare : public SSLKeyShare {
  public:
@@ -441,9 +544,11 @@ constexpr NamedGroup kNamedGroups[] = {
     {NID_secp521r1, SSL_GROUP_SECP521R1, "P-521", "secp521r1"},
     {NID_X25519, SSL_GROUP_X25519, "X25519", "x25519"},
     {NID_X25519Kyber768Draft00, SSL_GROUP_X25519_KYBER768_DRAFT00,
-     "X25519Kyber768Draft00", ""},
+     "X25519Kyber768Draft00", "Xyber768D00"},
     {NID_X25519MLKEM768, SSL_GROUP_X25519_MLKEM768, "X25519MLKEM768", ""},
     {NID_ML_KEM_1024, SSL_GROUP_MLKEM1024, "MLKEM1024", ""},
+    {NID_P256Kyber768Draft00, SSL_GROUP_P256_KYBER768_DRAFT00,
+     "P256Kyber768Draft00", "P256Kyber768D00"},
 };
 
 static_assert(std::size(kNamedGroups) == kNumNamedGroups,
@@ -455,6 +560,8 @@ Span<const NamedGroup> NamedGroups() { return kNamedGroups; }
 
 Span<const uint16_t> DefaultSupportedGroupIds() {
   static const uint16_t kDefaultSupportedGroupIds[] = {
+      SSL_GROUP_X25519_MLKEM768,
+      SSL_GROUP_P256_KYBER768_DRAFT00,
       SSL_GROUP_X25519,
       SSL_GROUP_SECP256R1,
       SSL_GROUP_SECP384R1,
@@ -478,6 +585,8 @@ UniquePtr<SSLKeyShare> SSLKeyShare::Create(uint16_t group_id) {
       return MakeUnique<X25519MLKEM768KeyShare>();
     case SSL_GROUP_MLKEM1024:
       return MakeUnique<MLKEM1024KeyShare>();
+    case SSL_GROUP_P256_KYBER768_DRAFT00:
+      return MakeUnique<P256Kyber768Draft00KeyShare>();
     default:
       return nullptr;
   }
diff --git a/ssl/ssl_lib.cc b/ssl/ssl_lib.cc
index f64b103fb..fe5bb9bc7 100644
--- a/ssl/ssl_lib.cc
+++ b/ssl/ssl_lib.cc
@@ -397,6 +397,7 @@ ssl_ctx_st::ssl_ctx_st(const SSL_METHOD *ssl_method)
       channel_id_enabled(false),
       grease_enabled(false),
       permute_extensions(false),
+      disable_second_keyshare(false),
       allow_unknown_alpn_protos(false),
       false_start_allowed_without_alpn(false),
       handoff(false),
@@ -527,6 +528,7 @@ SSL *SSL_new(SSL_CTX *ctx) {
   ssl->config->retain_only_sha256_of_client_certs =
       ctx->retain_only_sha256_of_client_certs;
   ssl->config->permute_extensions = ctx->permute_extensions;
+  ssl->config->disable_second_keyshare = ctx->disable_second_keyshare;
   ssl->config->aes_hw_override = ctx->aes_hw_override;
   ssl->config->aes_hw_override_value = ctx->aes_hw_override_value;
   ssl->config->compliance_policy = ctx->compliance_policy;
@@ -586,6 +588,7 @@ SSL_CONFIG::SSL_CONFIG(SSL *ssl_arg)
       jdk11_workaround(false),
       quic_use_legacy_codepoint(false),
       permute_extensions(false),
+      disable_second_keyshare(false),
       alps_use_new_codepoint(true) {
   assert(ssl);
 }
@@ -3331,6 +3334,15 @@ int SSL_set1_curves_list(SSL *ssl, const char *curves) {
   return SSL_set1_groups_list(ssl, curves);
 }
 
+void SSL_use_second_keyshare(SSL *ssl, int enabled) {
+  ssl->config->disable_second_keyshare = !enabled;
+}
+
+void SSL_CTX_use_second_keyshare(SSL_CTX *ctx, int enabled) {
+  ctx->disable_second_keyshare = !enabled;
+}
+
+
 namespace fips202205 {
 
 // (References are to SP 800-52r2):
@@ -3342,7 +3354,9 @@ namespace fips202205 {
 // Section 3.3.1
 // "The server shall be configured to only use cipher suites that are
 // composed entirely of NIST approved algorithms"
-static const uint16_t kGroups[] = {SSL_GROUP_SECP256R1, SSL_GROUP_SECP384R1};
+static const uint16_t kGroups[] = {
+    SSL_GROUP_P256_KYBER768_DRAFT00,
+    SSL_GROUP_SECP256R1, SSL_GROUP_SECP384R1};
 
 static const uint16_t kSigAlgs[] = {
     SSL_SIGN_RSA_PKCS1_SHA256,
diff --git a/ssl/ssl_test.cc b/ssl/ssl_test.cc
index 779a2c37a..36a0cab3b 100644
--- a/ssl/ssl_test.cc
+++ b/ssl/ssl_test.cc
@@ -506,6 +506,14 @@ static const CurveTest kCurveTests[] = {
         "MLKEM1024:X25519MLKEM768",
         {SSL_GROUP_MLKEM1024, SSL_GROUP_X25519_MLKEM768},
     },
+    {
+        "P256Kyber768Draft00",
+        {SSL_GROUP_P256_KYBER768_DRAFT00},
+    },
+    {
+        "P-256:P256Kyber768Draft00",
+        {SSL_GROUP_SECP256R1, SSL_GROUP_P256_KYBER768_DRAFT00},
+    },
 
     {
         "P-256:P-384:P-521:X25519",
@@ -668,7 +676,9 @@ TEST(SSLTest, CurveRules) {
 }
 
 TEST(SSLTest, DefaultCurves) {
-  const uint16_t kDefaults[] = {SSL_GROUP_X25519, SSL_GROUP_SECP256R1,
+  const uint16_t kDefaults[] = {SSL_GROUP_X25519_MLKEM768,
+                                SSL_GROUP_P256_KYBER768_DRAFT00,
+                                SSL_GROUP_X25519, SSL_GROUP_SECP256R1,
                                 SSL_GROUP_SECP384R1};
 
   // Test the group ID APIs.
@@ -1522,6 +1532,9 @@ static bool GetClientHello(SSL *ssl, std::vector<uint8_t> *out) {
 static size_t GetClientHelloLen(uint16_t max_version, uint16_t session_version,
                                 size_t ticket_len) {
   bssl::UniquePtr<SSL_CTX> ctx(SSL_CTX_new(TLS_method()));
+  // RTG-3417 bas: we need to disable PQ here so that the small ClientHello
+  // padding tests properly tests things.
+  SSL_CTX_set1_curves_list(ctx.get(), "X25519");
   bssl::UniquePtr<SSL_SESSION> session =
       CreateSessionWithTicket(session_version, ticket_len);
   if (!ctx || !session) {
@@ -6815,7 +6828,9 @@ TEST(SSLTest, ApplyHandoffRemovesUnsupportedCurves) {
 
   // The default list of groups is used before applying the handoff.
   EXPECT_THAT(server->config->supported_group_list,
-              ElementsAreArray({SSL_GROUP_X25519, SSL_GROUP_SECP256R1,
+              ElementsAreArray({SSL_GROUP_X25519_MLKEM768,
+                                SSL_GROUP_P256_KYBER768_DRAFT00,
+                                SSL_GROUP_X25519, SSL_GROUP_SECP256R1,
                                 SSL_GROUP_SECP384R1}));
   ASSERT_TRUE(SSL_apply_handoff(server.get(), handoff));
   EXPECT_EQ(1u, server->config->supported_group_list.size());
diff --git a/ssl/test/runner/basic_tests.go b/ssl/test/runner/basic_tests.go
index 08de8fa5f..dd945fa49 100644
--- a/ssl/test/runner/basic_tests.go
+++ b/ssl/test/runner/basic_tests.go
@@ -129,6 +129,7 @@ read alert 1 0
 				`write hs 1
 read hs 3
 write hs 1
+write hs 1
 read hs 2
 read hs 11
 read hs 12
@@ -1956,6 +1957,7 @@ read alert 1 0
 write hs 2
 write hs 8
 write hs 11
+write hs 11
 write hs 15
 write hs 20
 read hs 20
diff --git a/ssl/test/runner/cbc_tests.go b/ssl/test/runner/cbc_tests.go
index 6f49d12af..5e970b2b5 100644
--- a/ssl/test/runner/cbc_tests.go
+++ b/ssl/test/runner/cbc_tests.go
@@ -14,6 +14,8 @@
 
 package runner
 
+import "strconv"
+
 func addCBCPaddingTests() {
 	testCases = append(testCases, testCase{
 		name: "MaxCBCPadding",
@@ -104,6 +106,7 @@ func addCBCSplittingTests() {
 				"-partial-write",
 				// BoringSSL disables 3DES by default.
 				"-cipher", "ALL:3DES",
+				 "-curves", strconv.Itoa(int(CurveX25519)),
 			},
 		})
 	}
diff --git a/ssl/test/runner/common.go b/ssl/test/runner/common.go
index 7dbde72c9..9d18d9d45 100644
--- a/ssl/test/runner/common.go
+++ b/ssl/test/runner/common.go
@@ -2095,7 +2095,7 @@ type ProtocolBugs struct {
 	FailIfHelloRetryRequested bool
 
 	// FailIfPostQuantumOffered will cause a server to reject a ClientHello if
-	// post-quantum curves are supported.
+	// post-quantum curves are not supported.
 	FailIfPostQuantumOffered bool
 
 	// ExpectKeyShares, if not nil, lists (in order) the curves that a ClientHello
diff --git a/ssl/test/runner/curve_tests.go b/ssl/test/runner/curve_tests.go
index 8e7b0a45b..556bf314d 100644
--- a/ssl/test/runner/curve_tests.go
+++ b/ssl/test/runner/curve_tests.go
@@ -579,17 +579,6 @@ func addCurveTests() {
 		})
 	}
 
-	// ML-KEM and Kyber should not be offered by default as a client.
-	testCases = append(testCases, testCase{
-		name: "PostQuantumNotEnabledByDefaultInClients",
-		config: Config{
-			MinVersion: VersionTLS13,
-			Bugs: ProtocolBugs{
-				FailIfPostQuantumOffered: true,
-			},
-		},
-	})
-
 	for _, curve := range testCurves {
 		if !isMLKEMGroup(curve.id) {
 			continue
@@ -679,18 +668,19 @@ func addCurveTests() {
 		})
 	}
 
-	// As a server, ML-KEMs and Kyber are not yet supported by default.
+	// If ML-KEM is offered, both X25519 and ML-KEM should have a key-share.
 	testCases = append(testCases, testCase{
-		testType: serverTest,
-		name:     "PostQuantumNotEnabledByDefaultForAServer",
+		name: "NotJustMLKEMKeyShare",
 		config: Config{
-			MinVersion:       VersionTLS13,
-			CurvePreferences: []CurveID{CurveX25519MLKEM768, CurveMLKEM1024, CurveX25519Kyber768, CurveX25519},
-			DefaultCurves:    []CurveID{CurveX25519MLKEM768, CurveMLKEM1024, CurveX25519Kyber768},
+			MinVersion: VersionTLS13,
+			Bugs: ProtocolBugs{
+				ExpectedKeyShares: []CurveID{CurveX25519MLKEM768, CurveX25519},
+			},
 		},
 		flags: []string{
-			"-server-preference",
-			"-expect-curve-id", strconv.Itoa(int(CurveX25519)),
+			"-curves", strconv.Itoa(int(CurveX25519MLKEM768)),
+			"-curves", strconv.Itoa(int(CurveX25519)),
+			"-expect-curve-id", strconv.Itoa(int(CurveX25519MLKEM768)),
 		},
 	})
 
diff --git a/ssl/test/runner/ech_tests.go b/ssl/test/runner/ech_tests.go
index 2cd3c10d3..f19d8d20a 100644
--- a/ssl/test/runner/ech_tests.go
+++ b/ssl/test/runner/ech_tests.go
@@ -451,7 +451,8 @@ func addEncryptedClientHelloTests() {
 				expectMsgCallback += clientAndServerHello
 			}
 			// EncryptedExtensions onwards.
-			expectMsgCallback += `write hs 8
+			if protocol != dtls {
+				expectMsgCallback += `write hs 8
 write hs 11
 write hs 15
 write hs 20
@@ -462,6 +463,20 @@ write hs 4
 read ack
 read ack
 `
+			} else {
+				expectMsgCallback += `write hs 8
+write hs 11
+write hs 11
+write hs 15
+write hs 20
+read hs 20
+write ack
+write hs 4
+write hs 4
+read ack
+read ack
+`
+			}
 			if protocol != dtls {
 				expectMsgCallback = strings.ReplaceAll(expectMsgCallback, "write ack\n", "")
 				expectMsgCallback = strings.ReplaceAll(expectMsgCallback, "read ack\n", "")
@@ -2349,8 +2364,11 @@ read ack
 
 		// Test the message callback is correctly reported, with and without
 		// HelloRetryRequest.
-		clientAndServerHello := "write clienthelloinner\nwrite hs 1\nread hs 2\n"
-		clientAndServerHelloInitial := clientAndServerHello
+		clientAndServerHelloInitial := "write clienthelloinner\nwrite hs 1\nwrite hs 1\nread hs 2\n"
+		clientAndServerHello  := "write clienthelloinner\nwrite hs 1\nread hs 2\n"
+		if protocol != dtls {
+			clientAndServerHelloInitial = clientAndServerHello
+		}
 		if protocol == tls {
 			clientAndServerHelloInitial += "write ccs\n"
 		}
diff --git a/ssl/test/runner/extension_tests.go b/ssl/test/runner/extension_tests.go
index d6adb7759..4eb80aa8e 100644
--- a/ssl/test/runner/extension_tests.go
+++ b/ssl/test/runner/extension_tests.go
@@ -16,6 +16,7 @@ package runner
 
 import (
 	"fmt"
+	"strconv"
 )
 
 func addExtensionTests() {
@@ -1967,7 +1968,7 @@ func addExtensionTests() {
 		// This hostname just needs to be long enough to push the
 		// ClientHello into F5's danger zone between 256 and 511 bytes
 		// long.
-		flags: []string{"-host-name", "01234567890123456789012345678901234567890123456789012345678901234567890123456789.com"},
+		flags: []string{"-host-name", "01234567890123456789012345678901234567890123456789012345678901234567890123456789.com", "-curves", strconv.Itoa(int(CurveX25519))},
 	})
 
 	// Test that illegal extensions in TLS 1.3 are rejected by the client if
diff --git a/ssl/test/runner/key_update_tests.go b/ssl/test/runner/key_update_tests.go
index 0a9053038..5ce709589 100644
--- a/ssl/test/runner/key_update_tests.go
+++ b/ssl/test/runner/key_update_tests.go
@@ -14,7 +14,10 @@
 
 package runner
 
-import "slices"
+import (
+	"slices"
+	"strconv"
+)
 
 func addKeyUpdateTests() {
 	// TLS tests.
@@ -295,6 +298,7 @@ func addKeyUpdateTests() {
 			},
 		},
 		shimSendsKeyUpdateBeforeRead: true,
+		flags:            []string{"-curves", strconv.Itoa(int(CurveX25519))},
 	})
 
 	// Test that shim responds to KeyUpdate requests.
diff --git a/tool/client.cc b/tool/client.cc
index 0839d4880..be9b79259 100644
--- a/tool/client.cc
+++ b/tool/client.cc
@@ -125,6 +125,11 @@ static const struct argument kArguments[] = {
         kBooleanArgument,
         "Permute extensions in handshake messages",
     },
+    {
+        "-disable-second-keyshare",
+        kBooleanArgument,
+        "Do not send a second keyshare",
+    },
     {
         "-test-resumption", kBooleanArgument,
         "Connect to the server twice. The first connection is closed once a "
@@ -538,6 +543,10 @@ bool Client(const std::vector<std::string> &args) {
     SSL_CTX_set_permute_extensions(ctx.get(), 1);
   }
 
+  if (args_map.count("-disable-second-keyshare") != 0) {
+    SSL_CTX_use_second_keyshare(ctx.get(), 0);
+  }
+
   if (args_map.count("-root-certs") != 0) {
     if (!SSL_CTX_load_verify_locations(
             ctx.get(), args_map["-root-certs"].c_str(), nullptr)) {
-- 
2.40.0

